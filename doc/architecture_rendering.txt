DXRuby用ウィンドウシステムDXRubyWS 描画まわりのアーキテクチャについて

■１．はじめに

この文書は、2014/03/27時点での描画系アーキテクチャについて記述しています。
これ以後、予告無く変更される可能性がありますので、内容が仕様と食い違っている可能性があります。


■２．WSControl

renderとdrawという2つのメソッドが実装されています。ともにシステム側から適切なタイミングで呼ばれますので、コントロールを作った場合はそれぞれオーバーライドして適切に実装します。
renderメソッドは画像(self.image)を準備するためのメソッドです。このメソッドが終了した時点で、self.imageにそのまま描画していい状態の画像ができていなければなりません。
drawメソッドはSprite#drawのことで、自身を描画先(self.target)に描画するメソッドです。基本的に、描画そのものは自動で行われるので、メソッド定義がなくても描画はできます。ただし、例えばWSButtonのフォーカス枠のように、self.imageの外側に何かしらの描画を行いたい場合は、self.targetに対する描画という形でdrawメソッドに記述することになります。superを呼ぶのを忘れないようにしてください。


■３．WSContainer

WSContainerは配下に子コントロール、もしくは子コンテナを保持していますので、WSContainer#renderはそれらに対するrenderとdrawの呼び出しとして実装されています。renderメソッドをオーバーライドした場合、superの前で自身に対する描画を行うと子コントロールの奥に、superの後で描画すると子コントロールの手前に描画することができます。renderメソッドが完了したときに、self.image(RenderTargetオブジェクトが入っている)に自身配下のすべての描画が完了した状態となります。
逆に、drawメソッドは単純に自身をself.targetに描画するだけです。


■４．WSLightContainer

WSLightContainerはself.imageをnilにしたコンテナで、RenderTargetを保持しません。従って、renderは配下の子コントロールのrenderを呼び出し、drawは子コントロールのdrawを呼び出すだけとなります。
renderをオーバーライドしても描画する先がありませんし、drawをオーバーライドしても描画先の座標がわかりません(取得する方法はありますが)。基本的にWSLightContainerではrenderやdrawをオーバーライドすることは想定していません。


■５．ここまで










